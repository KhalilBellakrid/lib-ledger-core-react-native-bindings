// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from big_int.djinni

#import "RCTCoreBigInt.h"


@implementation RCTCoreBigInt
//Export module
RCT_EXPORT_MODULE(RCTCoreBigInt)

@synthesize bridge = _bridge;

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImplementations = [[NSMutableDictionary alloc] init];
    }
    return self;
}

+ (BOOL)requiresMainQueueSetup
{
    return NO;
}

/**
 * Adds two BigInt and returns a new BigInt with the result.
 * @params i Value to be added to this BigInt
 * @return The result of this + i
 */
RCT_REMAP_METHOD(add,add:(NSDictionary *)currentInstance withParams:(NSDictionary *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::add, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::add, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreBigInt *rctParam_i = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    BigInt *objcParam_0 = (BigInt *)[rctParam_i.objcImplementations objectForKey:i[@"uid"]];
    BigInt * objcResult = [currentInstanceObj add:objcParam_0];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBigInt *rctImpl_objcResult = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBigInt", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::add", nil);
    }

}

/**
 * Subtracts two BigInt and returns a new BigInt with result.
 * @params i Value to be subtracted to this BigInt
 * @return The result of this - i
 */
RCT_REMAP_METHOD(subtract,subtract:(NSDictionary *)currentInstance withParams:(NSDictionary *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::subtract, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::subtract, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreBigInt *rctParam_i = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    BigInt *objcParam_0 = (BigInt *)[rctParam_i.objcImplementations objectForKey:i[@"uid"]];
    BigInt * objcResult = [currentInstanceObj subtract:objcParam_0];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBigInt *rctImpl_objcResult = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBigInt", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::subtract", nil);
    }

}

/**
 * Multiplies two BigInt and returns a new BigInt with result.
 * @params i Value to be multiplied by this BigInt
 * @return The result of this * i
 */
RCT_REMAP_METHOD(multiply,multiply:(NSDictionary *)currentInstance withParams:(NSDictionary *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::multiply, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::multiply, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreBigInt *rctParam_i = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    BigInt *objcParam_0 = (BigInt *)[rctParam_i.objcImplementations objectForKey:i[@"uid"]];
    BigInt * objcResult = [currentInstanceObj multiply:objcParam_0];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBigInt *rctImpl_objcResult = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBigInt", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::multiply", nil);
    }

}

/**
 * Divides two BigInt and returns a new BigInt with result.
 * @params i Value by which this BigInt will be divided
 * @return The result of this / i
 */
RCT_REMAP_METHOD(divide,divide:(NSDictionary *)currentInstance withParams:(NSDictionary *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::divide, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::divide, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreBigInt *rctParam_i = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    BigInt *objcParam_0 = (BigInt *)[rctParam_i.objcImplementations objectForKey:i[@"uid"]];
    BigInt * objcResult = [currentInstanceObj divide:objcParam_0];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBigInt *rctImpl_objcResult = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBigInt", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::divide", nil);
    }

}

/**
 * Divides two BigInt and returns a new BigInt with result of the division and the remainder.
 * @params i Value by which this BigInteger is to be divided, and the remainder computed
 * @return A tuple of [this / i, this % i]
 */
RCT_REMAP_METHOD(divideAndRemainder,divideAndRemainder:(NSDictionary *)currentInstance withParams:(NSDictionary *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::divideAndRemainder, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::divideAndRemainder, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreBigInt *rctParam_i = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    BigInt *objcParam_0 = (BigInt *)[rctParam_i.objcImplementations objectForKey:i[@"uid"]];
    NSArray<BigInt *> * objcResult = [currentInstanceObj divideAndRemainder:objcParam_0];

    NSMutableArray *result = [[NSMutableArray alloc] init];
    for (id objcResult_elem in objcResult)
    {
        NSString *uuid = [[NSUUID UUID] UUIDString];
        RCTCoreBigInt *rctImpl_objcResult_elem = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
        [rctImpl_objcResult_elem.objcImplementations setObject:objcResult_elem forKey:uuid];
        NSDictionary *result_elem = @{@"type" : @"CoreBigInt", @"uid" : uuid };
        [result addObject:result_elem];
    }

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::divideAndRemainder", nil);
    }

}

/**
 * Raises this BigInt with an interger value.
 * @params i The exponent to which thi BigInt is raised
 * @return The result of this ^ exponent
 */
RCT_REMAP_METHOD(pow,pow:(NSDictionary *)currentInstance withParams:(int32_t)exponent withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::pow, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::pow, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    BigInt * objcResult = [currentInstanceObj pow:exponent];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBigInt *rctImpl_objcResult = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBigInt", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::pow", nil);
    }

}

/**
 * Formats this BigInt to a decimal string (e.g. BigInt("12345").toDecimalString(1, ".", ",") => "1,234.5")
 * @params precision The power of ten by wich this BigInt is divided
 * @params decimalSeparator The separator to use between the integer part and the decimal part
 * @params thousandSeparator The separator to use between each group of thousand units
 * @return The BigInt formatted as a decimal string
 */
RCT_REMAP_METHOD(toDecimalString,toDecimalString:(NSDictionary *)currentInstance withParams:(int32_t)precision
                                                                           decimalSeparator:(nonnull NSString *)decimalSeparator
                                                                          thousandSeparator:(nonnull NSString *)thousandSeparator withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::toDecimalString, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::toDecimalString, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    NSString * objcResult = [currentInstanceObj toDecimalString:precision decimalSeparator:decimalSeparator thousandSeparator:thousandSeparator];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::toDecimalString", nil);
    }

}

/**
 * Formats this BigInt to the interger representation of its internal value.
 * @params radix The radix of the number representation in which to format (right now 10 or 16)
 */
RCT_REMAP_METHOD(toString,toString:(NSDictionary *)currentInstance withParams:(int32_t)radix withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::toString, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::toString, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    NSString * objcResult = [currentInstanceObj toString:radix];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::toString", nil);
    }

}

/**
 * Returns the int representation of this BigInt. Note that if the BigInt is greater than 4 bytes the returned value
 * will be meaningless.
 * @return The int representation of this BigInt
 */
RCT_REMAP_METHOD(intValue,intValue:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::intValue, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::intValue, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    int32_t objcResult = [currentInstanceObj intValue];
    NSDictionary *result = @{@"value" : @(objcResult)};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::intValue", nil);
    }

}

/**
 * Compares two BigInt together.
 * @param i The value to compare with this BigInt
 * @return a positive value if this > i. A negative value if this < i. 0 if the two BigInts are equal
 */
RCT_REMAP_METHOD(compare,compare:(NSDictionary *)currentInstance withParams:(NSDictionary *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreBigInt::compare, first argument should be an instance of BigInt", nil);
    }
    BigInt *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling BigInt::compare, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreBigInt *rctParam_i = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    BigInt *objcParam_0 = (BigInt *)[rctParam_i.objcImplementations objectForKey:i[@"uid"]];
    int32_t objcResult = [currentInstanceObj compare:objcParam_0];
    NSDictionary *result = @{@"value" : @(objcResult)};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::compare", nil);
    }

}

/**
 * Creates a BigInt with a decimal string (e.g. "1.2000"). Note that every non numeric characters (except the decimal separator)
 * are ignored (e.g. "1ledger000" will be equal to "1000")
 * @param s The string with the decimal representation of the BigInt
 * @param precision The power of ten by which your decimal number must be multiplied in order to get his integer representation
 * @params decimalSeparator The decimal separator used by this string representation
 * @return The created BigInt
 */
RCT_REMAP_METHOD(fromDecimalString,fromDecimalStringwithParams:(nonnull NSString *)s
                                                     precision:(int32_t)precision
                                              decimalSeparator:(nonnull NSString *)decimalSeparator withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    BigInt * objcResult = [BigInt fromDecimalString:s precision:precision decimalSeparator:decimalSeparator];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBigInt *rctImpl_objcResult = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBigInt", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::fromDecimalString", nil);
    }

}

/**
 * Creates a BigInt with an integer string expressed in hexadecimal or decimal radix.
 * @param s The string to parse
 * @param radix The radix of the number representation (right now 10 or 16)
 * @return The created BigInt
 */
RCT_REMAP_METHOD(fromIntegerString,fromIntegerStringwithParams:(nonnull NSString *)s
                                                         radix:(int32_t)radix withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    BigInt * objcResult = [BigInt fromIntegerString:s radix:radix];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBigInt *rctImpl_objcResult = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBigInt", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::fromIntegerString", nil);
    }

}

/**
 * Creates a BigInt from a int64 value
 * @param l The value to convert
 * @return The created BigInt
 */
RCT_REMAP_METHOD(fromLong,fromLongwithParams:(int64_t)l withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    BigInt * objcResult = [BigInt fromLong:l];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBigInt *rctImpl_objcResult = (RCTCoreBigInt *)[self.bridge moduleForName:@"CoreBigInt"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBigInt", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling BigInt::fromLong", nil);
    }

}
@end
