// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from wallet.djinni

#import "RCTCoreWallet.h"


@implementation RCTCoreWallet
//Export module
RCT_EXPORT_MODULE(RCTCoreWallet)

@synthesize bridge = _bridge;

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImplementations = [[NSMutableDictionary alloc] init];
    }
    return self;
}

+ (BOOL)requiresMainQueueSetup
{
    return NO;
}

/**
 *Get name of wallet
 *@return string
 */
RCT_REMAP_METHOD(getName,getName:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getName, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getName, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    NSString * objcResult = [currentInstanceObj getName];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::getName", nil);
    }

}

/**
 *Get account with specific index
 *@param index, 32 bits integer, index of account in wallet
 *@param callback, Callback returning, if getAccount succeed, an Account object with given index
 */
RCT_REMAP_METHOD(getAccount,getAccount:(NSDictionary *)currentInstance withParams:(int32_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getAccount, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getAccount, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreAccountCallback *objcParam_1 = [[RCTCoreAccountCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getAccount:index callback:objcParam_1];

}

/**
 *Get number of accounts instanciated under wallet
 *@param callback, Callback returning, if getAccountCount succeed, a 32 bits integer representing number of accounts
 */
RCT_REMAP_METHOD(getAccountCount,getAccountCount:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getAccountCount, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getAccountCount, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreI32Callback *objcParam_0 = [[RCTCoreI32Callback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getAccountCount:objcParam_0];

}

/**
 *Get list of accounts instanciated under wallet in a given range
 *@param offset, 32 bits integer from which we retrieve accounts
 *@param count, 32 bits integer, number of accounts to retrieve
 *@param callback, ListCallback returning, if getAccounts succeed, list of Accounts object
 */
RCT_REMAP_METHOD(getAccounts,getAccounts:(NSDictionary *)currentInstance withParams:(int32_t)offset
                                                                              count:(int32_t)count withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getAccounts, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getAccounts, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreAccountListCallback *objcParam_2 = [[RCTCoreAccountListCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getAccounts:offset count:count callback:objcParam_2];

}

/**
 *Get index of next account to create
 *@return callback, Callback returning a 32 bits integer
 */
RCT_REMAP_METHOD(getNextAccountIndex,getNextAccountIndex:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getNextAccountIndex, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getNextAccountIndex, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreI32Callback *objcParam_0 = [[RCTCoreI32Callback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getNextAccountIndex:objcParam_0];

}

/**
 *Return event bus through which wallet synchronizes it's accounts and interact with blockchain
 *@return EventBus object
 */
RCT_REMAP_METHOD(getEventBus,getEventBus:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getEventBus, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getEventBus, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    EventBus * objcResult = [currentInstanceObj getEventBus];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreEventBus *rctImpl_objcResult = (RCTCoreEventBus *)[self.bridge moduleForName:@"CoreEventBus"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreEventBus", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::getEventBus", nil);
    }

}

/**
 *Return synchronization status wallet, true if at least one of accounts is synchronizing
 *@return bool
 */
RCT_REMAP_METHOD(isSynchronizing,isSynchronizing:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::isSynchronizing, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::isSynchronizing, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    BOOL objcResult = [currentInstanceObj isSynchronizing];
    NSDictionary *result = @{@"value" : @(objcResult)};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::isSynchronizing", nil);
    }

}

/**
 *Start synchronization of all accounts under wallet
 *@return EventBus object through which wallet get notified of account's synchronization status
 */
RCT_REMAP_METHOD(synchronize,synchronize:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::synchronize, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::synchronize, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    EventBus * objcResult = [currentInstanceObj synchronize];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreEventBus *rctImpl_objcResult = (RCTCoreEventBus *)[self.bridge moduleForName:@"CoreEventBus"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreEventBus", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::synchronize", nil);
    }

}

/**
 *Get wallet preferences
 *@return Preferences object
 */
RCT_REMAP_METHOD(getPreferences,getPreferences:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getPreferences, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getPreferences, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    Preferences * objcResult = [currentInstanceObj getPreferences];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCorePreferences *rctImpl_objcResult = (RCTCorePreferences *)[self.bridge moduleForName:@"CorePreferences"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CorePreferences", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::getPreferences", nil);
    }

}

/**
 *Return account's logger which provides all needed (e.g. database) logs
 *@return Logger Object
 */
RCT_REMAP_METHOD(getLogger,getLogger:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getLogger, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getLogger, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    Logger * objcResult = [currentInstanceObj getLogger];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreLogger *rctImpl_objcResult = (RCTCoreLogger *)[self.bridge moduleForName:@"CoreLogger"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreLogger", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::getLogger", nil);
    }

}

/**
 *Get preferences of specific account
 *@param index, 32 bits integer, account's index
 *@return Preferences object
 */
RCT_REMAP_METHOD(getAccountPreferences,getAccountPreferences:(NSDictionary *)currentInstance withParams:(int32_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getAccountPreferences, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getAccountPreferences, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    Preferences * objcResult = [currentInstanceObj getAccountPreferences:index];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCorePreferences *rctImpl_objcResult = (RCTCorePreferences *)[self.bridge moduleForName:@"CorePreferences"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CorePreferences", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::getAccountPreferences", nil);
    }

}

/**
 * asBitcoinLikeWallet(): Callback<BitcoinLikeWallet>;
 * asEthereumLikeWallet(): Callback<EthereumLikeWallet>;
 * asRippleLikeWallet(): Callback<RippleLikeWallet>;
 *Convert wallet to a Bitcoin one
 *@return BitcoinWallet object
 */
RCT_REMAP_METHOD(asBitcoinLikeWallet,asBitcoinLikeWallet:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::asBitcoinLikeWallet, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::asBitcoinLikeWallet, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    BitcoinLikeWallet * objcResult = [currentInstanceObj asBitcoinLikeWallet];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreBitcoinLikeWallet *rctImpl_objcResult = (RCTCoreBitcoinLikeWallet *)[self.bridge moduleForName:@"CoreBitcoinLikeWallet"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreBitcoinLikeWallet", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::asBitcoinLikeWallet", nil);
    }

}

/**
 *Get currency of wallet
 *@return Currency object
 */
RCT_REMAP_METHOD(getCurrency,getCurrency:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getCurrency, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getCurrency, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    Currency * objcResult = [currentInstanceObj getCurrency];

    NSString *uuid = [[NSUUID UUID] UUIDString];
    RCTCoreCurrency *rctImpl_objcResult = (RCTCoreCurrency *)[self.bridge moduleForName:@"CoreCurrency"];
    [rctImpl_objcResult.objcImplementations setObject:objcResult forKey:uuid];
    NSDictionary *result = @{@"type" : @"CoreCurrency", @"uid" : uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::getCurrency", nil);
    }

}

/**
 *Know if wallet is a Bitcoin one
 *@return bool
 */
RCT_REMAP_METHOD(isInstanceOfBitcoinLikeWallet,isInstanceOfBitcoinLikeWallet:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::isInstanceOfBitcoinLikeWallet, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::isInstanceOfBitcoinLikeWallet, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    BOOL objcResult = [currentInstanceObj isInstanceOfBitcoinLikeWallet];
    NSDictionary *result = @{@"value" : @(objcResult)};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::isInstanceOfBitcoinLikeWallet", nil);
    }

}

/**
 *Know if wallet is a Ethereum one
 *@return bool
 */
RCT_REMAP_METHOD(isInstanceOfEthereumLikeWallet,isInstanceOfEthereumLikeWallet:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::isInstanceOfEthereumLikeWallet, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::isInstanceOfEthereumLikeWallet, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    BOOL objcResult = [currentInstanceObj isInstanceOfEthereumLikeWallet];
    NSDictionary *result = @{@"value" : @(objcResult)};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::isInstanceOfEthereumLikeWallet", nil);
    }

}

/**
 *Know if wallet is a Ripple one
 *@return bool
 */
RCT_REMAP_METHOD(isInstanceOfRippleLikeWallet,isInstanceOfRippleLikeWallet:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::isInstanceOfRippleLikeWallet, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::isInstanceOfRippleLikeWallet, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    BOOL objcResult = [currentInstanceObj isInstanceOfRippleLikeWallet];
    NSDictionary *result = @{@"value" : @(objcResult)};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::isInstanceOfRippleLikeWallet", nil);
    }

}

/**
 *Get wallet type
 *@return WalletType object
 */
RCT_REMAP_METHOD(getWalletType,getWalletType:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getWalletType, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getWalletType, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    WalletType objcResult = [currentInstanceObj getWalletType];
    NSDictionary *result = @{@"value" : @(objcResult)};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling Wallet::getWalletType", nil);
    }

}

/**
 *Get last block of blockchain the wallet operates on
 *@param callback, Callback returning a Block object
 */
RCT_REMAP_METHOD(getLastBlock,getLastBlock:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getLastBlock, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getLastBlock, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreBlockCallback *objcParam_0 = [[RCTCoreBlockCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getLastBlock:objcParam_0];

}

/**
 *Return infos about the creation of specific account
 *@param accountIndex, 32 bits account, index of account in wallet
 *@param callback, Callback returning an AccountCreationInfo
 */
RCT_REMAP_METHOD(getAccountCreationInfo,getAccountCreationInfo:(NSDictionary *)currentInstance withParams:(int32_t)accountIndex withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getAccountCreationInfo, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getAccountCreationInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreAccountCreationInfoCallback *objcParam_1 = [[RCTCoreAccountCreationInfoCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getAccountCreationInfo:accountIndex callback:objcParam_1];

}

/**TODO */
RCT_REMAP_METHOD(getExtendedKeyAccountCreationInfo,getExtendedKeyAccountCreationInfo:(NSDictionary *)currentInstance withParams:(int32_t)accountIndex withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getExtendedKeyAccountCreationInfo, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getExtendedKeyAccountCreationInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreExtendedKeyAccountCreationInfoCallback *objcParam_1 = [[RCTCoreExtendedKeyAccountCreationInfoCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getExtendedKeyAccountCreationInfo:accountIndex callback:objcParam_1];

}

/**
 *Return infos about the next created account
 *@param callback, Callback returning an AccountCreationInfo
 */
RCT_REMAP_METHOD(getNextAccountCreationInfo,getNextAccountCreationInfo:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getNextAccountCreationInfo, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getNextAccountCreationInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreAccountCreationInfoCallback *objcParam_0 = [[RCTCoreAccountCreationInfoCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getNextAccountCreationInfo:objcParam_0];

}

/**TODO */
RCT_REMAP_METHOD(getNextExtendedKeyAccountCreationInfo,getNextExtendedKeyAccountCreationInfo:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::getNextExtendedKeyAccountCreationInfo, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::getNextExtendedKeyAccountCreationInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreExtendedKeyAccountCreationInfoCallback *objcParam_0 = [[RCTCoreExtendedKeyAccountCreationInfoCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getNextExtendedKeyAccountCreationInfo:objcParam_0];

}

/**
 *Get account from given account creation infos
 *@param accountCreationInfo, AccountCreationInfo object
 *@param callback, Callback returning an Account object with given creation infos
 */
RCT_REMAP_METHOD(newAccountWithInfo,newAccountWithInfo:(NSDictionary *)currentInstance withParams:(NSDictionary *)accountCreationInfo withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::newAccountWithInfo, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::newAccountWithInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreAccountCreationInfo *rctParam_accountCreationInfo = (RCTCoreAccountCreationInfo *)[self.bridge moduleForName:@"CoreAccountCreationInfo"];
    AccountCreationInfo *objcParam_0 = (AccountCreationInfo *)[rctParam_accountCreationInfo.objcImplementations objectForKey:accountCreationInfo[@"uid"]];
    RCTCoreAccountCallback *objcParam_1 = [[RCTCoreAccountCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj newAccountWithInfo:objcParam_0 callback:objcParam_1];

}

/**TODO */
RCT_REMAP_METHOD(newAccountWithExtendedKeyInfo,newAccountWithExtendedKeyInfo:(NSDictionary *)currentInstance withParams:(NSDictionary *)extendedKeyAccountCreationInfo withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::newAccountWithExtendedKeyInfo, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::newAccountWithExtendedKeyInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreExtendedKeyAccountCreationInfo *rctParam_extendedKeyAccountCreationInfo = (RCTCoreExtendedKeyAccountCreationInfo *)[self.bridge moduleForName:@"CoreExtendedKeyAccountCreationInfo"];
    ExtendedKeyAccountCreationInfo *objcParam_0 = (ExtendedKeyAccountCreationInfo *)[rctParam_extendedKeyAccountCreationInfo.objcImplementations objectForKey:extendedKeyAccountCreationInfo[@"uid"]];
    RCTCoreAccountCallback *objcParam_1 = [[RCTCoreAccountCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj newAccountWithExtendedKeyInfo:objcParam_0 callback:objcParam_1];

}

/**
 *Erase data (in user's DB) relative to wallet since given date
 *@param date, start date of data deletion
 */
RCT_REMAP_METHOD(eraseDataSince,eraseDataSince:(NSDictionary *)currentInstance withParams:(nonnull NSDate *)date withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreWallet::eraseDataSince, first argument should be an instance of Wallet", nil);
    }
    Wallet *currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling Wallet::eraseDataSince, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
    }
    RCTCoreErrorCodeCallback *objcParam_1 = [[RCTCoreErrorCodeCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj eraseDataSince:date callback:objcParam_1];

}
@end
